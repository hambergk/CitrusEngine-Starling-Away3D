package  {	import utils.*;	import com.citrusengine.core.State;	import away3d.debug.AwayStats;	import com.citrusengine.view.away3dview.Away3DView;	import away3d.containers.View3D;	import away3d.entities.Mesh;	import away3d.primitives.CubeGeometry;	import away3d.materials.ColorMaterial;	import com.citrusengine.objects.Box2DPhysicsObject;	import com.citrusengine.physics.box2d.Box2D;	import com.citrusengine.view.CitrusView;	//import com.citrusengine.objects.platformer.box2d.Platform;	import com.citrusengine.physics.nape.Nape;	import com.citrusengine.objects.platformer.nape.Platform;	import away3d.primitives.SphereGeometry;	import away3d.controllers.HoverController;	import away3d.materials.TextureMaterial;	import away3d.textures.BitmapTexture;	import away3d.lights.PointLight;	import away3d.lights.DirectionalLight;	import away3d.materials.lightpickers.StaticLightPicker;	import away3d.textures.BitmapCubeTexture;	import away3d.primitives.SkyBox;	import flash.geom.Vector3D;	import flash.events.MouseEvent;	import flash.events.Event;	import away3d.library.AssetLibrary;	import com.citrusengine.objects.platformer.nape.Hero;	import com.citrusengine.view.away3dview.AnimationSequence;	import away3d.loaders.parsers.MD2Parser;	import away3d.materials.methods.FilteredShadowMapMethod;	import away3d.utils.Cast;	import flash.display.Bitmap;	import away3d.animators.VertexAnimationSet;	import away3d.events.AssetEvent;	import away3d.events.LoaderEvent;	import away3d.library.assets.AssetType;	import away3d.animators.VertexAnimator;	import away3d.loaders.parsers.DAEParser;	import away3d.containers.ObjectContainer3D;	import away3d.core.base.Geometry;	import away3d.core.render.BackgroundImageRenderer;	import away3d.loaders.Loader3D;	import away3d.loaders.AssetLoader;	import flash.net.URLRequest;	import com.citrusengine.objects.CitrusSprite;	import starling.display.Image;	import starling.textures.Texture;	import away3d.primitives.PlaneGeometry;	import flash.display.Sprite;	import away3d.core.managers.Stage3DProxy;	import away3d.core.managers.Stage3DManager;	import away3d.events.Stage3DEvent;	import flash.display.Stage;	import flash.display.StageAlign;	import flash.display.StageScaleMode;	import starling.core.Starling;	//import starling.events.Event;		public class Away3DGameState extends State {				// Stage manager and proxy instances		private var stage3DManager : Stage3DManager;		private var stage3DProxy : Stage3DProxy;				//camera		private var hc : HoverController;				//lights		private var lightPicker : StaticLightPicker;		private var shadowMapMethod : FilteredShadowMapMethod;		public var lightsArray = [];				//Hero		private var hero:Hero;		private var heroMaterial:TextureMaterial;		private var animationSet:VertexAnimationSet;		private var heroMesh:Mesh;				//Starling		private var starlingScene : Starling;		//Time		private var _timeDelta : Number = 0;				[Embed(source="3dassets/pknight.md2", mimeType="application/octet-stream")]		public static var heroMd2:Class;		public function Away3DGameState() {		  this.addEventListener(Event.ADDED_TO_STAGE, init);		}						/**		 * Global initialise function		 */		 		private function init(e:Event):void		{			// Define a new Stage3DManager for the Stage3D objects			stage3DManager = Stage3DManager.getInstance(stage);		  			// Create a new Stage3D proxy to contain the separate views			stage3DProxy = stage3DManager.getFreeStage3DProxy();			stage3DProxy.addEventListener(Stage3DEvent.CONTEXT3D_CREATED, onContextCreated);			stage3DProxy.antiAlias = 8;			stage3DProxy.color = 0x0;		}								private function onContextCreated(event : Stage3DEvent) : void {			initAway3D();			initStarling();			initListeners();		}						/**		 * Set up the rendering processing event listeners		 */		 		private function initListeners() : void {			stage3DProxy.addEventListener(Event.ENTER_FRAME, stage3DProxyRenderer);		}		 		 		/**		 * The main rendering loop		 */		 		private function stage3DProxyRenderer(event : Event) : void {			// Stacking order determines layer position			 			// Render the Starling animation layer			 starlingScene.nextFrame();			 			// Render the Away3D layer			(view as Away3DView).viewRoot.render();						//run the original update function			super.update(_timeDelta);		}										override public function initialize():void {			//initialize was moved to initAway3D in order to change the default behaviour of CE		}						public function initAway3D():void { 			super.initialize();						// Framerate counter			addChild(new AwayStats(view as View3D));						// Physics engine				var physics:Nape = new Nape("nape");			//physics.visible = true; //wireframe mode			add(physics);			(view as Away3DView).viewRoot.camera.lookAt(new Vector3D); //default 0 0 0			(view as Away3DView).viewRoot.camera.z = -1000;			(view as Away3DView).viewRoot.camera.y = 300;						hc = new HoverController((view as Away3DView).viewRoot.camera, null, 270, -6, 1000,-45,45);			// Global directional light			var light:DirectionalLight = new DirectionalLight(-1, -2, 1);			light.color = 0xffffff;			light.ambient = 1;			light.specular = 0.2;			light.ambientColor = 0x181818;			lightsArray.push(light);			(view as Away3DView).viewRoot.scene.addChild(light);			// Create a global shadow map method based on the directional light			 shadowMapMethod = new FilteredShadowMapMethod(light);						// Creating color picker			lightPicker = new StaticLightPicker(lightsArray);			// Hero code			heroMaterial = new TextureMaterial(Cast.bitmapTexture(new KnightTexture()));			heroMaterial.lightPicker = lightPicker;			heroMaterial.gloss = 30;			heroMaterial.specular = 1;			heroMaterial.ambient = 1;			heroMaterial.shadowMethod = shadowMapMethod;						add(new Platform("floor", {x:stage.stageWidth / 2, y:stage.stageHeight - 30, width:3000, height:10}));						AssetLibrary.loadData(new heroMd2(), null, null, new MD2Parser());			AssetLibrary.addEventListener(AssetEvent.ASSET_COMPLETE, onAssetComplete);			AssetLibrary.addEventListener(LoaderEvent.RESOURCE_COMPLETE, onResourceComplete);		}		/**		 * Make sure and call this override to specify Away3D view.		 */ 		 		override protected function createView():CitrusView {			//stage3DProxy parameter added to the Away3DView class			return new Away3DView(this, "2D", 4, stage3DProxy);		}						/**		 * Init the Starling sprites		 */		 		private function initStarling() : void		{			// Create the Starling scene to add the background			starlingScene = new Starling(StarlingBg, stage, stage3DProxy.viewPort, stage3DProxy.stage3D);					}						/**		 * Listener function for asset complete event on loader		 */				private function onAssetComplete(event:AssetEvent):void		{			if (event.asset.assetType == AssetType.MESH) {				heroMesh = event.asset as Mesh;				heroMesh.scale(3);			} else if (event.asset.assetType == AssetType.ANIMATION_SET) {				animationSet = event.asset as VertexAnimationSet;			}		}						/**		 * Resource complete function		 */		 		private function onResourceComplete(event:LoaderEvent = null):void		{			heroMesh.castsShadows = true;			heroMesh.material = heroMaterial;						//create animator			var vertexAnimator:VertexAnimator = new VertexAnimator(animationSet);			//trace state names			for(var i:int = 0; i < animationSet.states.length; i++) {				trace(animationSet.states[i].stateName);							}			heroMesh.animator = vertexAnimator;			hero = new MyHero("hero", {x:150, y:stage.stageHeight - 30, width:80, height:90, view:heroMesh});			add(hero);						hero.onAnimationChange.add(AnimationChange);		}						/**		 * overrides the default update function		 */				override public function update(timeDelta:Number):void {			_timeDelta = timeDelta;		}						/**		 * overrides the default hero class animation change		 */		 		private function AnimationChange() {			//"run" is the 3D models name for the "walk" action						if(hero.animation == "walk") {				heroMesh.animator.play("run");					} else if(hero.animation == "idle") {				heroMesh.animator.play("stand");			}					}	}	}